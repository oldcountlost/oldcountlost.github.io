---
title: 'Blog Post number 1'
date: 2025-03-17
permalink: /posts/2012/08/blog-post-1/
tags:
  - cool posts
  - category1
  - category2
---

在deepseek-R1的帮助下，写了一个脚本实现了简单的细胞距离的计算与检验脚本。记录一下

``` python
import tifffile
import numpy as np
import matplotlib.pyplot as plt
from skimage import filters, measure, morphology, segmentation
from skimage import feature
from scipy import ndimage as ndi
from scipy.spatial import distance_matrix
import pandas as pd
import seaborn as sns


# ====================
# 1. 图像读取与质量评估
# ====================



def load_and_assess_image(image_path):
    """读取多通道TIFF图像并进行基础质量评估"""
    # 读取图像 (假设形状为 [H, W, C])
    img = tifffile.imread(image_path)  # 输出形状 (Height, Width, Channels)
    print(f"Dimensions：{img.shape} (H, W, C)")

    # 可选：将通道维度移到第一维 [C, H, W] (根据后续处理需求)
    # img = np.moveaxis(img, -1, 0)  # 如果后续步骤需要通道在前

    # 质量评估（保持原始维度）
    quality_report = {}
    for ch in range(img.shape[2]):  # 遍历通道维度
        channel_img = img[:, :, ch]  # 获取第ch个通道
        quality_report[f'channel{ch}'] = {
            'mean': np.mean(channel_img),
            'sd': np.std(channel_img),
            'range': (np.min(channel_img), np.max(channel_img)),
            'signal/noise ratio': np.mean(channel_img)/np.std(channel_img)
        }
    
    # 绘制通道概览（需要调整通道索引）
    plt.figure(figsize=(12, 6))
    for i in range(img.shape[2]):
        plt.subplot(1, img.shape[2], i+1)
        plt.imshow(img[:, :, i], cmap='gray')  # 修改此处索引
        plt.title(f'channel {i}')
        plt.axis('off')
    plt.tight_layout()
    
    return img, quality_report

# ====================
# 2. 细胞分割与分类
# ====================

def process_channel(image, channel_idx, min_cell_size=100):
    """处理单个通道进行细胞分割"""
    # 获取指定通道数据
    channel_img = image[:, :, channel_idx]  # 修改此处索引
    
    # 后续处理保持不变
    blurred = filters.gaussian(channel_img, sigma=2)
    thresh = filters.threshold_otsu(blurred)
    binary = blurred > thresh

    # 形态学处理
    cleaned = morphology.remove_small_objects(binary, min_size=min_cell_size)
    cleaned = morphology.binary_closing(cleaned, morphology.disk(3))

    # 分水岭分割
    
    distance = ndi.distance_transform_edt(cleaned)
    peaks = feature.peak_local_max(distance, min_distance=7, labels=cleaned)
    mask = np.zeros(distance.shape, dtype=bool)
    mask[tuple(peaks.T)] = True
    markers = measure.label(mask)
    labels = segmentation.watershed(-distance, markers, mask=cleaned)

    # 特征提取
    props = measure.regionprops_table(labels, intensity_image=image,
                                    properties=['label', 'area', 
                                               'centroid', 
                                               'mean_intensity'])
    
    return pd.DataFrame(props), labels


# ====================
# 3. 距离分析
# ====================

def calculate_distances(cells_df):
    """计算不同类型细胞之间的距离"""
    cell_types = cells_df['cell_type'].unique()
    distance_results = {}

    # 计算类间距离
    for i, type1 in enumerate(cell_types):
        for j, type2 in enumerate(cell_types):
            coords1 = cells_df[cells_df['cell_type'] == type1][['centroid-0', 'centroid-1']].values
            coords2 = cells_df[cells_df['cell_type'] == type2][['centroid-0', 'centroid-1']].values
            
            if len(coords1) == 0 or len(coords2) == 0:
                continue
            
            dist_mat = distance_matrix(coords1, coords2)
            if type1 == type2:
                np.fill_diagonal(dist_mat, np.inf)  # 排除自比较
            
            min_dists = np.min(dist_mat, axis=1)
            key = f"{type1}-{type2}" if type1 != type2 else f"{type1}_intra"
            distance_results[key] = min_dists[min_dists != np.inf]
    return distance_results

'''

======

You can have many headings
======

Aren't headings cool?
------
