---
title: 'perturb-seq 数据分析： oNMF'
date: 2025-05-30
permalink: /posts/2025/05/blog-post-6/
tags:
  - perturbseq
  - gene program
  - regulatory network
  - NMF
---


## NMF与oNMF
对于NMF，其实现方法是，对于W和H的更新做乘法（不改变正负号），或者是矩阵的值下限设置为0。
oNMF在NMF的基础上多了一个限制，就是orthogonal，即正交。我们既可以设置W正交也可以设置H正交。
![what is oNMF](https://user-images.githubusercontent.com/50495107/182271297-015ab74c-69d6-4f79-b246-b5de6a709601.png)

## perturb-seq
对于基因数据( \\(n\\)个细胞，\\(g\\)个基因，\\(k\\)个gene program )，\\[\mathbf{X}\_{n \times g} = \mathbf{W}\_{n \times k} \cdot \mathbf{H}\_{k \times g} \\] 我们设置其\\(\mathbf{H}\_{k \times g}\\)正交，即一个基因只能存在于一个gene program 中，\\(k\\)个gene program之间正交。

## 代码
```python

import numpy as np
import pandas as pd
import scanpy as sc
import sys
#sys.path.append("/ahg/regevdata/projects/Cell2CellCommunication/code/MIMOSCA")

%matplotlib inline
import matplotlib.pyplot as plt

import dspin

sc.settings.verbosity = 3  # verbosity: errors (0), warnings (1), info (2), hints (3)
sc.settings.set_figure_params(dpi=200, color_map='viridis')
#sc.logging.print_versions()
import matplotlib
matplotlib.rcParams['pdf.fonttype'] = 42
matplotlib.rcParams['ps.fonttype'] = 42
test_adata = sc.read_h5ad('/home/yzeng/proj/Perturb_seq/rerun/DSPIN/thomsonlab_signaling/thomsonlab_signaling_filtered_2500_scvi_umap.h5ad')




dir = '/home/yzeng/proj/Perturb_seq/rerun/'

adata=sc.read(dir+'Clean_Counts.h5ad')
adata.raw = adata
adata.obs['batch_wider'] = 1
df2 = pd.DataFrame(adata.obs[['batch','batch_wider']]).pivot(columns='batch').fillna('0')
for obs_add in df2['batch_wider'].columns:
    obs_n = 'batch' + obs_add
    adata.obs[obs_n] = df2['batch_wider'][obs_add].astype(float)
adata.var['mt'] = adata.var_names.str.startswith('MT-')  # annotate the group of mitochondrial genes as 'mt'
sc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True)
adata.obs
cell_cycle_path = '/home/yzeng/proj/Perturb_seq/yzeng/Perturb_seq_analysis/pertpy_analysis/data/regev_lab_cell_cycle_genes.txt'
cell_cycle_genes = [x.strip() for x in open(cell_cycle_path)]
s_genes = cell_cycle_genes[:43]
g2m_genes = cell_cycle_genes[43:]
print(len(cell_cycle_genes))
cell_cycle_genes = [x for x in cell_cycle_genes if x in adata.var_names]
adata.layers['counts'] = adata.X.copy()
sc.pp.normalize_total(adata,target_sum=1e4)
sc.pp.log1p(adata)
adata.layers['normalized'] = adata.X.copy()
sc.pp.highly_variable_genes(adata,min_mean=0.0125,max_mean=3,min_disp=0.5)
adata.obs['if_control'] = [ 1 if x=='control' else 0 for x in adata.obs['gene.compact'] ]
adata.X = adata.layers['normalized'].copy()
#adata.obs['leiden'] =  adata.obs['gene.compact']
adata.obs['sample_id'] = adata.obs['guide.compact']

num_repeat=5
num_spin = 24
num_pool = num_spin
model = DSPIN(adata, save_path, num_spin=num_spin, filter_threshold = 0.001)
print("num SPIN is "+ str(num_spin))
model.gene_program_discovery(balance_obs='gene.compact', num_repeat=num_repeat, seed=seed ) #, prior_programs = gene_programs_from_elasticNet )


from dspin.plot import assign_program_position
#sc.set_figure_params(figsize=(3, 3))
#sc.pl.umap(acts, color= list(acts.var_names), cmap='RdBu_r', vcenter=0, ncols= 20)
program_umap_pos = assign_program_position(model.program_representation, adata.obsm['X_umap'], repulsion=4)
np.save(save_path + 'program_umap_pos.npy', program_umap_pos)
from dspin.plot import gene_program_on_umap
gene_program_on_umap(model.program_representation, adata.obsm['X_umap'], program_umap_pos, subsample=False)



model.network_inference(sample_col_name='guide.compact',  params={'stepsz': 0.01, 'mcmc_samplingsz': 2e6})


cur_j = model.network
cur_h = model.responses

sc.set_figure_params(figsize=[4, 4])
import matplotlib as mpl
cmap_hvec = mpl.colors.LinearSegmentedColormap.from_list("", ['#3285CC', '#FFFFFF', '#E84B23'])
j_thres = 1
plt.imshow(cur_j, cmap=cmap_hvec, vmin=- j_thres, vmax=j_thres)
plt.colorbar()




batch = [ 1 for x in np.unique(adata.obs['guide.compact']) ]
if_control = np.array([ 1 if x.split('-')[0] == 'CONTROL' else 0  for x in  np.unique(adata.obs['guide.compact']) ] )
if_control
model.response_relative_to_control( if_control = if_control,  batch_index= batch )
h_rela = model.relative_responses

from sklearn.cluster import KMeans
kmeans_spin = KMeans(n_clusters=4).fit(h_rela)
spin_order = np.argsort(kmeans_spin.labels_)


num_cluster = 30
num_cluster_lv2 = 7
num_cluster_lv3 = 3

kmeans_hvec = KMeans(n_clusters=num_cluster, random_state=0, n_init=10).fit(h_rela.T)
kmeans_hvec_lv2 = KMeans(n_clusters=num_cluster_lv2, random_state=0, n_init=10).fit(h_rela.T)
kmeans_hvec_lv3 = KMeans(n_clusters=num_cluster_lv3, random_state=0, n_init=10).fit(h_rela.T)

samp_order = np.lexsort((kmeans_hvec.labels_, kmeans_hvec_lv2.labels_, kmeans_hvec_lv3.labels_))


sample_list_struc = [ list(set(adata[ adata.obs['gene.compact'] == gene,].obs['guide.compact'] ))  for gene in  np.unique(adata.obs['gene.compact']) ]     
h_rela_sub = np.zeros((num_spin, len( np.unique(adata.obs['gene.compact']))))

for ii, samp_sub in enumerate(  sample_list_struc ):
    h_rela_sub[:, ii] = np.mean(h_rela[:, [list(samp_list).index(samp) for samp in samp_sub]], axis=1)
sc.set_figure_params(figsize=[16, 7])

plt.imshow((h_rela_sub * (np.abs(h_rela_sub) > 0.1))[spin_order,:], cmap=cmap_hvec, vmin=- 1.5, vmax=1.5, aspect='auto')
plt.xticks(np.arange(len(np.unique(adata.obs['gene.compact']))), np.unique(adata.obs['gene.compact']), fontsize=10, rotation=90);
plt.yticks(np.arange(num_spin), fontsize=10)
# spin_name = np.arange(num_spin)
plt.yticks(np.arange(len(spin_order)),  np.array(spin_name)[spin_order], fontsize=12, rotation=0);
plt.grid()
plt.colorbar()


```
![gene program ~ KO group p-value](../../../../images/oNMF_program_correlation.png)
![gene program ~ KO group p-value](../../../../images/oNMF_program_embedding.png)

![gene program ~ KO group p-value](../../../../images/oNMF_program_KO_graph.png)
![gene program ~ KO group p-value](../../../../images/oNMF_program_KO_heatmap.png)




